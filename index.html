<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/dc/1.7.1/dc.css">
    <link rel="stylesheet" href="//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.css">
    <style type="text/css">
      #map {
        height: 400px;
        width: 100%;
        border-bottom: 5px solid #3182bd;
      }

      .fast {
        color: #3182bd;
      }

      .slow {
        color: #e6550d;
      }

      h6 {
        text-align: center;
      }
    </style>
    <script>
      // Constants
      var daysOfWeek = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun' ];
      var height = 200;
      var margins = { top: 10, right: 10, bottom: 20, left: 40 };
      var width = 450;

      // Globals
      var charts = {}, dimensions, map, incidents, min_response_time, max_response_time;
    </script>
  </head>
  <body>
    <div id="viz" style="display:none;">

      <div id="map"></div>

      <div class="container">
        <div class="row">
          <div class="col-sm-12" id="count">
            <h6>Hexagon size correlates to amount of emergency responses. Color gradient shows <span class="fast">fast</span> to <span class="slow">slow</span> response times.</h6>
            <h1>ERDA <strong class="filter-count"></strong> selected out of <strong class="total-count"></strong> records</h1>
            <h4>ERDA (Emergency Response Data Analysis) is an effort to apply statistical analysis to emergency response data obtained from the city of Washington, DC.</h4>
          </div>
        </div>
        <div class="row">
          <div class="col-sm-3" id="service">
            <h4>Service <span class="filter"></span> <a class="reset" href="javascript:charts.service.filterAll();dc.redrawAll('incidents');" style="display:none;">reset</a></h4>

            <div class="clearfix"></div>
          </div>
          <div class="col-sm-3" id="day">
            <h4>Day <a class="reset" href="javascript:charts.day.filterAll();dc.redrawAll('incidents');" style="display:none;">reset</a></h4>
            <div class="clearfix"></div>
          </div>
          <div class="col-sm-6" id="response-min">
            <h4>Response Time <span class="filter"></span> <a class="reset" href="javascript:charts.response.filterAll();dc.redrawAll('incidents');" style="display:none;">reset</a></h4>
            <div class="clearfix"></div>
          </div>
        </div>
      </div>
    </div>
    <script src="//cdnjs.cloudflare.com/ajax/libs/spin.js/2.0.1/spin.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.10/d3.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.7/crossfilter.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/dc/1.7.1/dc.js"></script>
    <script src="//api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js"></script>
    <script src="d3.hexbin.v0.min.js"></script>
    <script src="hexbin.js"></script>
    <script>
      var spinner = new Spinner().spin();
      document.body.appendChild(spinner.el);

      d3.csv('./data/incidents_with_latlongs.csv', parse, process);

      function process(err, csv) {
        if (err) return window.alert(err);

        csv = csv.filter(function(r) { return !!r.response_min && r.response_min < 180; })

        min_response_time = d3.min(csv, function(d) { return d.response_min; });
        max_response_time = d3.max(csv, function(d) { return d.response_min; });

        incidents = crossfilter(csv);
        dimensions = dimensionify(incidents);

        charts.count = dc.dataCount('#count', 'incidents')
          .dimension(incidents)
          .group(incidents.groupAll());

        charts.service = dc.pieChart('#service', 'incidents')
          .height(height)
          .dimension(dimensions.byService)
          .group(dimensions.byService.group());

        charts.day = dc.pieChart('#day', 'incidents')
          .height(height)
          .label(function(d) { return daysOfWeek[d.data.key]; })
          .dimension(dimensions.byDay)
          .group(dimensions.byDay.group());

        charts.response = dc.barChart('#response-min', 'incidents')
          .height(height)
          .width(width)
          .margins(margins)
          .x(d3.scale.linear().domain([0, 45]))
          .elasticY(true)
          .round(Math.round)
          .dimension(dimensions.byResponseMin)
          .group(dimensions.byResponseMin.group());

        document.getElementById('viz').style.display = 'block';

        // After displaying, setup the map
        map = L.mapbox.map('map', 'trevorgerhardt.j7kk2e33', {
          touchZoom: false,
          scrollWheelZoom: false
        }).setView([38.899316235331575, -77.0309829711914], 11);

        // Generate Hexbins
        map.on('viewreset', function() {
          showMap();
        });

        // Attach to dc.js renderLet
        charts.response.renderlet(function(c) {
          dc.events.trigger(function() {
            // Redraw the hexbins
            showMap();
          });
        });

        dc.renderAll('incidents');
        spinner.stop();
      }

      function dimensionify(i) {
        return {
          byDay: i.dimension(function(d) { return d.date.getDay(); }),
          byHour: i.dimension(function(d) { return d.date.getHours(); }),
          byResponseMin: i.dimension(function(d) { return d.response_min; }),
          byService: i.dimension(function(d) { return d.service; }),
          byUnit: i.dimension(function(d) { return d.unit; })
        };
      }

      function parse(row) {
        return {
          date: new Date(row.year, row.month - 1, row.day, row.hour, row.minute, row.second),
          ll: [parseFloat(row.longitude), parseFloat(row.latitude) ],
          service: row.service,
          response_min: parseInt(row.response_min),
          unit: row.unit
        };
      }

      var _polys = [];
      function showMap() {
        var data = dimensions.byUnit.top(Infinity)
          .map(function(row) {
            var coords = row.ll;
            coords.response_min = row.response_min;
            return coords;
          })
          .filter(function(ll) {
            return !isNaN(ll[0]) && !isNaN(ll[1]);
          });

        _polys.forEach(map.removeLayer.bind(map));

        var $map = document.getElementById('map');
        var bounds = map.getBounds();
        var rmax = (bounds.getNorth() - bounds.getSouth()) / 20;

        var hexbins = hexbin(data, {
          cscale: function(bs) {
            var min = Infinity, max = -Infinity;
            for (var i = 0; i < bs.length; i++) {
              var b = bs[i];
              b.color = 0;
              for (var j = 0; j < b.length; j++) {
                b.color += b[j].response_min;
              }
              b.color = b.color / b.length;
              if (b.color > max) max = b.color;
              if (b.color < min) min = b.color;
            }
            return d3.scale.log()
              .domain([ min, max ])
              .range([ '#3182bd', '#e6550d' ]);
          },
          rscale: function(bs) {
            return d3.scale.log()
              .domain([ 1, d3.max(bs, function(b) { return b.length; }) || 1 ])
              .range([ rmax / 4, rmax ]);
          },
          height: $map.clientHeight,
          rmax: rmax,
          width: $map.clientWidth
        });

        _polys = hexbins.map(function(d) {

          var p = L.polygon(d.coords, {
              stroke: true,
              weight: 1,
              color: '#e5e5e5',
              fill: true,
              fillOpacity: 0.75,
              fillColor: d.color
            })
            .addTo(map)
            .bindPopup('Total Responses: ' + d.rvalue + '<br>'
              + 'Avg. Response Time: ' + Math.round(d.cvalue) + 'min');
          return p;
        });
      }
    </script>
  </body>
</html>